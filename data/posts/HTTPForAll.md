# 모든 개발자를 위한 HTTP 웹 기본 지식 (by. 영한님)

HTTP 전체적으로 정리한 글이 없어서 아래 강의를 듣고 개인적으로 간략하게 정리한 글입니다.  
이해하기 어려울 수 있으니 자세한 내용은 강의를 수강해주세요!  
출처:[모든 개발자를 위한 HTTP 웹 기본 지식](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)

<details>
  <summary>1. 인터넷 네트워크</summary>

### 인터넷을 통해 수많은 컴퓨터 중 원하는 컴퓨터에게 전달하는 방법?

1. 컴퓨터마다 IP 주소를 부여받는다.

- IP가 인터넷 프로토콜 역할을 한다.

2. 지정한 IP 주소에 패킷이라는 통신 단위로 데이터를 전달한다.

- IP패킷에는 출발지 IP, 목적지 IP, 데이터 등이 담겨있다.

### IP 프로토콜의 한계

1. 비연결성
2. 비신뢰성
3. 프로그램 구분

### IP 프로토콜의 해결방법 : TCP(전송 제어 프로토콜)

- TCP는 신뢰할 수 있는 프로토콜이며, 현재 대부분 TCP를 사용한다.
- TCP/IP 패킷 정보에는 IP 패킷 정보에 **출발 PORT, 목적지 PORT, 전송 제어, 순서, 검증 정보** 등이 함께 전달이 되므로 다음 문제들을 해결하였다.
  1. 데이터 전달 보증
  2. 순서 보장
  3. 연결지향 - TCP 3 way handshake(가상 연결)
- TCP 3 way handshake
  1. 클라이언트에서 서버로 접속 요청(SYN)를 한다.
  2. 서버에서 클라이언트에게 요청 수락(ACK)과 접속 요청(SYN)을 보낸다.
  3. 클라이언트에서 서버로 요청 수락(ACK)을 보낸다.
  4. 클라이언트와 서버 둘 다 연결이 되었다는 걸 인식한 후 데이터를 전송한다.
  - 요즘엔 최적화가 되어서 3번 과정을 할 때 같이 데이터를 전송한다.
  - 직접 연결이 된 게 아니라 서로 연결이 되었다고 하자라고 정의한 것.

### UDP

- IP에 PORT, 체크섬만 추가되었으므로, IP 프로토콜의 한계를 가지고 있다.
- 장점이라면 TCP에 비해 단순하고 빠르다.

### PORT

한 번에 둘 이상 연결하기 위해 PORT가 탄생했다.  
비유하자면 아파트(== IP) 몇 동 몇 호(== PORT)

- 0 ~ 65535까지 할당 가능하다.
- 0 ~ 1023: 잘 알려진 포트로 사용하지 않는 것이 좋다.
  - FTP - 20, 21
  - TELNET - 23
  - HTTP - 80
  - HTTPS - 443

### DNS

IP는 기억하기 어렵고, 변경될 수 있다. 그러므로 Domain Name System이 탄생했다.

- DNS 서버에 도메인 명에 따른 IP가 있다.
- 클라이언트에서 DNS 서버에 도메인 명을 보내면 서버에서 IP를 보내준다.

</details>

<details>
  <summary>2. URI와 웹 브라우저 요청 흐름</summary>

### URI(Uniform Resource Identifier)

URI는 Locator, Name 또는 둘 다 추가로 분류될 수 있다.  
URI 뜻

- Uniorm: 리소스 식별하는 통일된 방식
- Resource: 자원, URI로 식별할 수 있는 모든 것
- Identifier: 다른 항목과 구분하는데 필요한 정보
  URL은 리소스가 있는 위치를 지정, URN은 리소스에 이름을 부여

### URL

- scheme://host:port/path?query#fragment
- 프로토콜: 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙
  ex. http, https, ftp 등
- http는 80포트, https는 443 포트를 주로 사용

### HTTP와 HTTPS

HTTP는 데이터가 plain text로 전송되기 때문에 보안되지 않은 프로토콜로 간주됩니다. 이는 데이터가 네트워크에 접근할 수 있는 모든 사용자에게 가로채어 읽힐 수 있으며, 암호화의 부재로 데이터 조작 및 기타 보안 위협에 취약합니다.  
HTPS는 SSL 또는 TLS 프로토콜을 사용하여 데이터를 암호화하기 때문에 HTTP보다 안전합니다. HTTPS 연결을 설정하기 위해서 SSL/TLS 인증서가 필요하고 이 인증서는 신뢰할 수 있는 인증 기관에서 발급되며, 웹 사이트의 신뢰성과 신원을 확인합니다. 브라우저가 HTTPS를 사용하여 웹사이트를 연결할 때 SSL/TLS 인증서를 확인하고 유효하고 변경되지 않았는지 확인합니다.  
요약하면, HTTPS는 브라우저와 웹 서버 간에 전송되는 데이터를 암호화하여 HTTP보다 추가적인 보안 기능을 제공합니다. 이를 통해 로그인 자격 증명, 신용 카드 정보 및 기타 개인 데이터와 같은 민감한 정보가 악의적인 사용자에 의해 가로채거나 수정되는 것을 방지할 수 있습니다.

</details>

<details>
  <summary>3. HTTP 기본</summary>

### HTTP

- HTTP 메시지에 모든 것을 전송한다.
  - HTML, TEXT, IMAGE, 음성, 영상, 파일, JSON 등 모든 형태의 데이터가 전송 가능하다.
  - 서버 간에 데이터를 주고 받을 때도 대부분 HTTP 사용한다.
- 기반 프로토콜
  - TCP: HTTP/1.1, HTTP/2
  - UDP: HTTP/3
  - HTTP/2, HTTP3은 HTTP/1.1에 성능 향상 정도이다.
  - 우리에게 가장 중요한 버전은 HTTP/1.1이다.
- 특징
  - 클라이언트 서버 구조
  - 무상태 프로토콜(stateless), 비연결성
  - HTTP 메시지
  - 단순함, 확장 가능

### 클라이언트 서버 구조

클라이언트가 서버에 요청을 보내고, 서버가 요청에 대한 결과를 만들어서 응답한다.

### 무상태 프로토콜

- 서버가 클라이언트의 상태를 보존하지 않는다.
- 장점
  - 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입하면 해결된다
  - 응답 서버를 쉽게 바꿀 수 있다
  - 무한한 서버 증설이 가능하다.
- 한계
  - 전송된 데이터가 stateful보다 많다.
  - 실무에 사용될 때 상태 유지가 필요한 경우가 있다.(로그인 유지)

### 비연결성

- HTTP는 기본이 연결을 유지하지 않는 모델이다.
- 장점
  - 일반적으로 초 단위 이하의 빠른 속도로 응답한다.
  - 서버 자원을 매우 효율적으로 사용할 수 있다.
- 한계
  - TCP/IP 연결을 새로 맺어야 한다. - 3 way handshake 시간 추가
  - 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 js,css,image 등 많은 자원이 다운로드 된다.
- 극복
  - 지금은 HTTP 지속 연결로 문제 해결되었다.
  - HTTP/2.0, 3.0에서 최적화가 되었다.

### HTTP 메시지

**요청 메시지**

1. 시작라인

   - HTTP 메서드(GET,POST,PUT,DELETE...)
   - 요청대상: 절대경로(/)로 시작한다. (절대경로?query)
   - HTTP 버전

2. HTTP 헤더

   - HTTP 전송에 필요한 모든 부가정보

3. HTTP 메시지 바디
   - 실제 전송할 데이터

**응답 메시지**

1. 시작라인

   - HTTP 버전
   - HTTP 상태 코드
   - 이유 문구

2. HTTP 헤더

   - HTTP 전송에 필요한 모든 부가정보

3. HTTP 메시지 바디

   - 실제 전송할 데이터

</details>

<details>
  <summary>4. HTTP 메서드</summary>

### URI 고민

- 리소스의 의미를 고민해라
  - 금을 캐다 => 금이 리소스이다, 캐는 것은 리소스가 아니다.
- 리소스를 어떻게 식별할까?
  - 금을 캐고 정제하는 것을 모두 배제
  - 금이라는 리소스만 식별하면 된다. => **금 리소스를 URI에 매핌**
- 리소스와 행위를 분리해라.
  - 행위는 HTTP 메서드가 대신 해준다.
    최근에는 resource 대신 representation 용어로 쓰임

### HTTP 메서드 종류

- GET:리소스 조회
- POST:요청 데이터 처리, 주로 등록에 사용
- PUT:리소스를 대체, 해당 리소스가 없으면 생성
- PATCH:리소스 부분 변경
- DELETE:리소스 삭제
  기타
- HEAD: GET과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 변환
- OPTIONS: 대상 리소스에 대한 통신 가능 옵션을 설명(주로 CORS에서 사용)
- CONNECT, TRACE => 거의 사용 안함

### GET

- 서버에 전달하고 싶은 데이터는 query를 통해서 전달
- 메시지 바디에 데이터를 넣어서 보내지 않는다.(가능은 함)

### POST

- 메시지 바디를 통해 서버로 요청 데이터 전달
- 서버는 요청 데이터 처리한다. 주로 신규 리소스 등록에 사용한다.
  > 요청 데이터를 어떻게 처리한다는 뜻일까? (예제)
  >
  > - HTML 양식에 입력된 필드와 같은 데이터 블록을 데이터 처리 프로세스에 제공한다.
  > - 게시판, 뉴스 그룹, 메일링 리스트, 블로그 또는 유사한 기사 그룹에 메시지 게시한다.
  > - 서버가 아직 식별하지 않은 새 리소스를 생성한다.
  > - 기존 자원에 데이터를 추가한다.
  >
  > 정리: 이 리소스 URI에 POST 요청이 오면 요청 데이터를 어떻게 처리할지 리소스마다 따로 정해야 한다. 왜? 정해진 것이 없으니까.

### PUT

- 리소스가 있으면 **완전 대체**, 없으면 생성 => 덮어버린다.
- **클라이언트가 리소스 위치를 알고 URI를 지정한다** => POST와 차이점
- 예시로 '/members/100'에 PUT 요청을 하면 기존 데이터 삭제하고 요청 데이터로 덮어버린다.

### PATCH

- 리소스 부분적으로 변경한다.
- PATCH가 안되는 서버에는 POST를 사용하면 된다.

### DELETE

- 리소스를 제거한다.

### HTTP 메서드의 속성

**안전**

- 호출해도 리소스를 변경하지 않는다.
- GET, HEAD, Options, Trace는 안전하고 그 외는 불안전함.
  **멱등**
- 같은 요청을 여러번 호출해도 결과가 똑같다.
- GET, PUT(결과를 대체하기 때문에 최종 결과는 같다.), DELETE는 멱등하다.
- POST는 멱등하지 않다.
- Q&A
  - **어떻게 활용되나?**  
    A. 자동 복구 메커니즘, 서버가 정상 응답을 못주었을 때 클라이언트가 같은 요청을 다시 해도 되는가의 판단 근거가 된다.
  - **재요청 중간에 다른 곳에서 리소스를 변경해버리면?**  
     A. 멱등은 외부 요인으로 중간에 리소스가 변경되는 것까지는 고려하진 않는다.  
     ex. GET(요청실패)=>PUT=>GET(요청성공)으로 리소스가 변경되더라도 PUT으로 바뀐 내용을 가져온다.
    **캐시가능**
- 응답 결과 리소스를 캐시해서 사용해도 되는가?
- GET, HEAD, POST, PATCH 캐시 가능하다. 보통은 GET, HEAD 정도만 캐시로 사용
</details>

<details>
  <summary>5. HTTP 메서드 활용</summary>

### 클라이언트에서 서버로 데이터 전송하는 방법

1. 쿼리 파라미터를 통한 데이터 전송

- GET
- 주로 정렬 필터(검색어)

2. 메시지 바디를 통한 데이터 전송

- POST,PUT,PATCH
- 회원 가입, 상품 주문, 리소스 등록, 리소스 변경

### 정적 데이터 조회

- 이미지, 정적 텍스트 문서를 받을 때 GET 사용
- 정적 데이터는 일반적으로 쿼리 파라미터 없이 리소스 경로로 단순하게 조회가 가능하다.

### 동적 데이터 조회

- 쿼리 파라미터를 사용하여 데이터를 전달하고 GET 사용
- 주로 검색, 게시판 목록에서 정렬 필터에 사용된다.

### HTML Form 데이터 전송

- default: HTTP 바디에 input name=input value 데이터가 들어가고 HTTP 헤더에 Content-Type:application/x-www-form-urlencoded가 추가된다.
- 파일과 같이 전송되는 경우: multipart/form-data를 사용한다.  
  다른 종류의 여러 파일과 함께 전송가능하기 때문에 이름에 multipart가 붙여졌다.

### HTTP API 데이터 전송

- json 파일을 넣고 Content-Type에 application/json을 주로 사용한다.

### 회원 관리 시스템 API 만들기(예제)

> 회원 목록 /members -> GET
> 회원 등록 /members -> POST
> 회원 조회 /members/{id} -> GET
> 회원 수정 /members/{id} -> PATCH,PUT,POST
> 회원 삭제 /members/{id} -> DELETE

- 신규 자원 등록을 POST로 할 때 **클라이언트는 등록될 리소스의 URI를 모른다.** 왜? **서버가 새로 등록된 리소스 URI를 생성하기 때문**이다.
- 서버가 관리하는 리소스 디렉토리를 **컬렉션**라고 한다. 여기 예제에서는 /members가 컬렉션이다.

### 관리 시스템을 PUT으로 사용할 때

- 신규 자원 등록을 PUT으로 할 때 **클라이언트는 리소스의 URI를 알아야 한다.** 왜? **클라이언트가 PUT으로 요청보낼 때 URI를 지정해야하기 때문**이다.
- 클라이언트가 관리하는 리소스 저장소를 **스토어**라고 한다.
- PUT은 거의 사용하지 않지만, 파일 업로드를 주로 사용하는 서버 같은 경우는 신규 자원 등록할 때 사용한다, 대부분 POST 기반으로 사용한다.

### HTML FORM 사용

- HTML FORM은 GET, POST만 지원
- 컨트롤 URI
  - HTTP 메서드로 해결하기 애매한 경우 POST로 /new, /edit, /delete같이 동사를 직접 사용하여 컨트롤 URI를 만든다.
  </details>

<details>
  <summary>6. HTTP 상태코드</summary>

### 상태 코드

클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능이다.

- 1xx(Informational): 요청이 수신되어 처리중 (거의 사용하지 않음)
- 2xx(Successful): 요청 정상 처리
- 3xx(Redirection): 요청을 완료하려면 추가 행동이 필요
- 4xx(Client Error): 잘못된 문법등으로 서버가 요청을 수행할 수 없음
- 5xx(Server Error): 서버가 정상 요청을 처리하지 못함

### 2xx(Successful)

- 200 OK
- 201 Created : 요청 성공해서 새로운 리소스가 생성됨 => 생성된 리소스는 응답의 Location 헤더 필드로 식별
- 202 Accepted : 요청이 접수되었으나 처리가 완료되지 않았음
- 204 No Content : 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없음 => 웹 문서 편집기에서 save 버튼

### 3xx(Redirection)

- 리다이렉션
  - 웹 브라우저가 3xx 응답의 결과에 Loaction 헤더가 있으면, Location 위치로 자동 이동한다.
  - 영구 리다이렉션 - 특정 리소스의 URI가 영구적으로 이동
  - 일시 리다이렉션 - 일시적인 변경 ex. 주문 완료 후 주문 내역 화면으로 이동
  - 특수 리다이렉션 - 결과 대신 캐시를 사용

영구 리다이렉션

- 301 Moved Permanently : 리다이렉션시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있다(MAY).
- 308 Permanent Redirect : 301과 기능은 같고, 리다이렉트시 요청 메서드와 본문을 유지한다.(MUST NOT)

일시 리다이렉션

- 302 Found : 리다이렉션시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있다(MAY).
- 307 Temporary Redirect : 302와 기능은 같고, 리다이렉트시 요청 메서드와 본문을 유지한다.(MUST NOT)
- 303 See Other : 302와 기능은 같고, 요청 메서드가 GET으로 변경(MUST)

특수 리다이렉션

- 300 안씀
- 304 Not Modified
  - 캐시를 목적으로 사용한다.
  - 클라이언트에게 리소스가 수정되지 않았음을 알려준다. 따라서 클라이언트는 로컬PC에 저장된 캐시를 재사용한다. (즉, 캐시로 리다이렉트한다.)
  - 304 응답은 응답에 메시지 바디를 포함하면 안된다.(왜? 로컬 캐시를 사용해야 하므로)
  - 조건부 GET, HEAD 요청시 사용된다.

### 4xx(Client Error)

- 클라리언트가 이미 잘못된 요청, 데이터를 보내고 있기 때문에, 똑같은 재시도가 실패한다.
- 400 Bad Request : 요청 파라미터가 잘못되거나, API 스펙에 맞지 않을 떄 등 생긴다.
- 401 Unauthorized : 인증이 필요하다는 메시지이다.
- 403 Forbidden : 서버가 요청을 이해했지만 승인을 거부함. 인증 자격 증명은 있지만 접근 권한이 불충분한 경우 발생한다.
- 404 Not Found : 요청 리소스를 찾을 수 없음 또는 해당 리소스를 숨기고 싶을 때 사용한다.

**인증과 인가의 차이**

- 인증(Authentication): 본인이 누구인지 확인(로그인)
- 인가(Authorization): 권한부여(Admin 권한)

### 5xx(Server Error)

- 서버에 문제가 있기 때문에 재시도 하면 성공할 수도 있다.
- 500 Internal Server Error : 서버 내부 오류로 발생
- 503 Service Unavailable : 서버가 일시적인 과부하 또는 예정된 작업으로 요청을 처리할 수 없을 때 발생
</details>

<details>
  <summary>7. HTTP 헤더1 - 일반 헤더</summary>

### HTTP BODY

- 메시지 본문을 통해 표현 데이터 전달
- 메시지 본문을 **페이로드**라고 한다.
- representation(표현)은 요청이나 응답에서 전달한 실제 데이터
- 표현 헤더는 표현 데이터를 해석할 수 있는 정보를 제공한다.

### 표현 헤더

- Content-Type: 표현 데이터의 형식 (text/html; charset=utf-8, application/json, image/png 등)
- Content-Encoding: 표현 데이터의 압축 방식 (gzip, deflate, identity=압축 안한다는 뜻)
- Content-Language: 표현 데이터의 자연 언어 (ko, en, en-US)
- Content-Length: 표현 데이터의 길이
- 표현 헤더는 전송, 응답 둘 다 사용된다.

### 협상(Content Negotiation)

클라이언트가 선호하는 표현 요청

- Accept: 클라이언트가 선호하는 미디어 타입 전달
- Accept-Charset: 클라이언트가 선호하는 문자 인코딩
- Accept-Encoding: 클라이언트가 선호하는 압축 인코딩
- Accept-Language: 클라이언트가 선호하는 언어
- 협상 헤더는 요청시에만 사용

### 협상과 우선순위 1

- Quality Values(q) 값 사용
- 0~1, 클수록 높은 순위
- 생략하면 1
- 예시: Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7

### 협상과 우선순위 2

- 구체적인 것이 우선한다.
- 예시: text/\*,text/plain,text/plain;format=flowed,\*/\*
  1. text/plain;format=flowed
  2. text/plain
  3. text/\*
  4. \*/\*

### 전송 방식

- 단순 전송: 한 번에 요청하고 한 번에 받는 것
- 압축 전송: gzip 같은 걸로 압축하고 전송하는 것
- 분할 전송: 덩어리로 쪼개서 요청하는 것(서버에서도 덩어리마다 보냄) => Content-Length를 보내면 안됨
- 범위 전송: 범위를 지정해서 요청하는 것

### 일반 정보

- From
  - 유저 에이전트의 이메일 정보
  - 검색 엔진 같은 곳에서 사용(일반적으로 잘 사용안함)
  - 요청에서 사용
- Referer
  - 이전 웹사이트 주소
  - A -> B로 이동하는 경우 `referer: A`를 포함해서 요청
  - 요청에서 사용
- User-Agent
  - 클라이언트의 애플리케이션 정보(웹 브라우저 정보 등)
  - 통계 정보로 활용, 어떤 종류의 브라우저에서 장애가 발생하는지 파악 가능하다.
  - 요청에서 사용
- Server
  - 요청을 처리하는 ORIGIN 서버(목적지 서버)의 소프트웨어 정보
  - 응답에서 사용
- Date
  - 메시지가 발생한 날짜와 시간
  - 응답에서 사용

### 특별한 정보

- **Host**
  - 요청한 호스트 정보(도메인)
  - 필수!
  - 하나의 서버가 여러 도메인을 처리해야 할 때
- **Location**
  - 페이지 리다이렉션
  - 응답코드 201에서 Location 값은 요청에 의해 생성된 리소스 URI
  - 3xx에서 Location 값은 요청을 자동으로 리디렉션하기 위한 대상 리소스
- Allow
  - 허용 가능한 HTTP 메서드
  - 405(Method Not Allowed) 에서 응답에 포함해야 함
- Retry-After
  - 유저 에이전트가 다음 요청을 하기까지 기다려야하는 시간
  - 503(Service Unavailable)에서 서비스가 언제까지 불능인지 알려줄 수 있음

### 인증

- Authorization
  - 클라이언트 인증 정보를 서버에 전달
- WWW-Authenticate
  - 리소스 접근시 필요한 인증 방법 정의
  - 401과 함께 응답함

### 쿠키

- 쿠키 사용 전 문제점들

  - HTTP는 무상태 프로토콜이므로 서버는 상태를 유지하지 않는다.
    1차 대안: 모든 요청에 사용자 정보 포함(쿼리 이용 등) => 보안 같은 문제들 발생, 개발자가 힘듬,
    2차 대안: 쿠키도입!

- 쿠키 사용처
  - 사용자 로그인 세션 관리
  - 광고 정보 트래킹
- 쿠키 정보는 항상 서버에 전송됨 그래서 ...
  - 네트워크 트래픽 추가 유발
  - 최소한의 정보만 사용(세션 id, 인증 토큰)
  - 서버에 전송하지 않고, 웹 브라우저 내부에 저장하고 싶으면 웹 스토리지 참고
  - 보안에 민감한 데이터는 저장하면 안된다.

### 쿠키 - 생명 주기

- Set-Cookie: expires=Sat,26~~
- Set-Cookie: max-age=3600(3600초)
- 영속 쿠키: 만료 날짜를 입력하면 해당 날짜까지 유지된다. 위와 같이 날짜가 명시된 쿠키
- 세션 쿠키: 만료 날짜를 생략하면 브라우저 종료시 까지만 유지된다. => 브라우저 껏다 키면 다시 로그인하라고 한다면 요런 케이스

### 쿠키 - 도메인

ex. domain=example.org 명시 or 생략

- 명시: 명시한 문서 기준 도메인 + 서브 도메인 포함  
  example.org 뿐만 아니라 dev.example.org도 쿠키 접근 가능
- 생략: 현재 문서 기준 도메인만 적용  
  example.org에서만 쿠키 접근 가능

### 쿠키 - 경로

ex. path=/home

- 이 경로를 포함한 하위 경로 페이지만 쿠키 접근 가능하다
- 보통은 path=/루트로 지정한다.

### 쿠키 - 보안

- Secure
  - 쿠키는 http, https를 구분하지 않고 전송
  - Secure를 적용하면 https인 경우에만 전송
- HttpOnly
  - XSS 공격 방지
  - 자바스크립트에서 접근 불가
  - HTTP 전송에만 사용
- SameSite
  - XSRF 공격 방지
  - 요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키 전송
  </details>

<details>
  <summary>8. HTTP 헤더2 - 캐시와 조건부</summary>

### 캐시 기본 동작

1. 캐시가 없을 때

- 데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운 받아야한다.
- 브라우저 로딩 속도가 느려 사용자 경험을 안좋게 한다.

2. 캐시 적용했을 때

- 캐시가 유효한 시간을 헤더에 추가한다. cache-control: max-age=60(캐시 유효한 시간)
- 다시 요청을 보냈을 때 유효한 시간 내면 캐시를 사용한다.
- 캐시 시간이 초과하면 다시 네트워크를 통해 다운로드 받는다.

### 검증 헤더와 조건부 요청

캐시 만료후에도 서버에서 데이터를 변경하지 않았다면??

- 서버에 요청을 보낼 때 검증 헤더를 추가한다.
- 서버는 검증 헤더를 확인한다.
- 데이터가 다르다면 바뀐 데이터를 보내고, 아니라면 **304 Not Modified를 보내고 HTTP Body가 없다.**즉, 헤더 메타 정보만 보낸다.
- 클라이언트에서 Not Modified를 받으면 캐시에 있는 데이터를 사용한다.

### 검증 헤더와 조건부 요청 2

**검증 헤더**

- 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
- Last-Modified: 날짜(UTC) or ETag

**조건부 요청 헤더**

- 검증 헤더로 조건에 따른 분기
- If-Modified-since == Last-Modified
- If-None-Match == Etag
- 데이터가 수정되었다면? 200 OK와 바디를 포함해서 보낸다.
- 수정되지 않았다면? 304 Not Modified와 헤더 메타 정보만 보낸다.

Last-Modified, If-Modified-since 단점

- 1초 미만 단위 캐시 조정 불가능
- 날짜 기반의 로직 사용
- 별도의 캐시 로직을 관리할 수 없다.

ETag, If-None-Match

- 캐시용 데이터에 임의의 고유한 버전 이름을 달 수 있다.
- 데이터가 변경되면 이 이름을 바꾸어서 변경한다(Hash를 다시 생성)
- 날짜가 아닌 ETag를 보내서 같으면 유지, 다르면 받기

### 캐시와 관련된 헤더들

- Cache-Control: ~

  - max-age (캐시 유효시간, 초단위)
    **프록시 서버 관련**
  - pulbic (응답이 pulbic 캐시에 저장)
  - private (응답이 해당 사용자만을 위한 것임)
  - s-maxage (프록시캐시에만 적용되는 max-age)  
    **캐시 무효화 관련**
  - no-cache (데이터는 캐시해도 되지만, 항상 origin 서버에 검증하고 사용)
  - no-store (데이터에 민감한 정보가 있으므로 저장하면 안됨)
  - must-revalidate (캐시 만료후 최초 조회시 origin 서버에 검증해야함)

  완전 무효화하기 위해서는 Cache-Control: no-cache, no-store, must-revalidate

</details>
